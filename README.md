# compose-expect-swift

Compose Swift Interop is a experimental tool that helps you define expect composable functions to be
implemented later on the iOS Project using Swift. The tool works by generating Kotlin and Swift code
based on the Annotated Expect Composable and generated a View factory interface that will be implemented
by you in the iOS Project. Also the tool generates a ObservableObject for each parameter in the Expect Composable function
allowing to easily keep the state parameter updated in the SwiftUI View.

## Let see in practice how it works

Annotate a `@Composable expect fun` with `@ExpectSwiftView`

commonMain:
```kotlin
@ExpectSwiftView
@Composable
expect fun MapView(
    modifier: Modifier = Modifier,
    title: String,
    coordinate: MapCoordinates,
)
```

On the iOS target (iosMain), we need to update your function that returns ComposeUIViewController
to receive the Factory interface (generated by the tool) in the function and provide it in the
Local Composition (Local Composition also generated).

iosMain:
```kotlin
fun MainViewController(
    generatedViewFactory: NativeViewFactory
): UIViewController = ComposeUIViewController {
    CompositionLocalProvider(
        LocalNativeViewFactory provides generatedViewFactory,
    ) {
        AppScreen()
    }
}
```

On iOS project, we need to implement the `NativeViewFactory`(generated by the tool) and pass it to `MainViewController`.
We receive a ObservableObject(generated by tool) that contains all State parameters from the defined expect function,
when Compose recompose with a new state, only that parameter will be updated on SwiftUI.

```swift
class SwiftUINativeViewFactory : NativeViewFactory {
    // SwiftUI type example (default annotation configuration)
    func createMapView(observable: MapViewObservable) -> AnyView {
        let view = NativeMapViewBinding(observable: observable)
        return AnyView(view)
    }
```

Let last part is to update the function that returns ComposeUIViewController to pass the defined
`SwiftUINativeViewFactory()` as parameter.

```swift
struct MainView : UIViewControllerRepresentable {
    func makeUIViewController(context: Context) -> some UIViewController {
        MainViewController(generatedViewFactory: SwiftUINativeViewFactory())
    }
    
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {}
}
```

### How to configure in the project

The code generator relies on two main libraries: KSP and SKIE(support since 0.8.4).

```kotlin
plugins {
    id("co.touchlab.skie") version "0.9.3"
    id("com.google.devtools.ksp") version "YOUR KSP VERSION HERE"
}

kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation("co.touchlab.compose:compose-swift-interop:0.1.0-ALPHA")
        }
    }
}

dependencies {
    val composeSwiftInteropKsp = "co.touchlab.compose:compose-swift-interop-ksp:0.1.0-ALPHA"
    "kspCommonMainMetadata"(composeSwiftInteropKsp)
    "kspAndroid"(composeSwiftInteropKsp)

    "kspIosSimulatorArm64"(composeSwiftInteropKsp)
    "kspIosArm64"(composeSwiftInteropKsp)
    "kspIosX64"(composeSwiftInteropKsp)

    skieSubPlugin("co.touchlab.compose:compose-swift-interop-skie:0.1.0-ALPHA")
}

tasks.withType<KspTaskNative>().configureEach {
    options.add(SubpluginOption("apoption", "swiftInterop.targetName=$target"))
}

// support for generating ksp code in commonCode
// see https://github.com/google/ksp/issues/567
tasks.withType<KotlinCompile<*>>().configureEach {
    if (name != "kspCommonMainKotlinMetadata") {
        dependsOn("kspCommonMainKotlinMetadata")
    }
}
```

### Multi Module setup

Sample can be found [here](sample/multimodule).

Considerations:
1. Each of your Modules should have a different Factory Name configured, so you have two options:
   1. Making sure that each Expect Composable has being configured with a Custom Factory name.
   2. Or less error prune, using KSP property `ksp { arg("compose-swift-interop.defaultFactoryName", "MyModuleNameView") }`. (See sample bellow)
2. The modules should be exported to iOS (aka ``framework { export(project("your_module")) }``)

The modules containing Compose UI and the expect composable with @ExpectSwiftView
```kotlin
plugins {
    id("com.google.devtools.ksp") version "YOUR KSP VERSION HERE"
}

kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation("co.touchlab.compose:compose-swift-interop:0.1.0-ALPHA")
        }
    }
}

dependencies {
    val composeSwiftInteropKsp = "co.touchlab.compose:compose-swift-interop-ksp:0.1.0-ALPHA"
    "kspCommonMainMetadata"(composeSwiftInteropKsp)
    "kspAndroid"(composeSwiftInteropKsp)

    "kspIosSimulatorArm64"(composeSwiftInteropKsp)
    "kspIosArm64"(composeSwiftInteropKsp)
    "kspIosX64"(composeSwiftInteropKsp)
}

tasks.withType<KspTaskNative>().configureEach {
    options.add(SubpluginOption("apoption", "compose-swift-interop.targetName=$target"))
}

ksp {
    // Configure the module with a custom default factory name, the default is called "NativeView"
    arg("compose-swift-interop.defaultFactoryName", "MyModuleNameView")
}

// support for generating ksp code in commonCode
// see https://github.com/google/ksp/issues/567
tasks.withType<KotlinCompile<*>>().configureEach {
    if (name != "kspCommonMainKotlinMetadata") {
        dependsOn("kspCommonMainKotlinMetadata")
    }
}
```

The umbrella module (that module that packs all modules to generate the iOS Framework)
```kotlin
plugins {
    id("co.touchlab.skie") version "0.9.3"
}

dependencies {
    skieSubPlugin("co.touchlab.compose:compose-swift-interop-skie:0.1.0-ALPHA")
}

// configuring the export like this
kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            ...

            export(project(":the-module-that-contains-compose"))
        }
    }
}
```

## Deeper dive into the usage

### Annotation configurations

```
annotation class ExpectSwiftView(
    val factoryName: String = "NativeView",
    val type: ViewType = ViewType.SwiftUI,
    val keepStateCrossNavigation: Boolean = false
)
```

The code generation works by generating the actual function in the iOS target, this function
also uses a generate Factory interface that contains all factory functions to each of the annotated
Composable function with `@ExpectSwiftView`.

`factoryName`: Defines the name of the generated factories interfaces. By default the name of the factory
is called `NativeView`, when the following functions, interfaces are generated with this name, for example:
NativeView**Factory**(Used on iOS for the implementing the factory),
**Local**NativeView**Factory**(The local composition that you have to provide in order to the expect function to work).

This is mostly important when you want to fragment in multiple factories with their own responsibility or when you are
using Multi module setup and don't want to use the KSP property, you should use a custom Factory Name for all your Expect Swift Views.

`keepStateCrossNavigation`: Used when your native view (for example your SwiftUI View) has it own state
and it should be kept when navigating back, for example, if you are replacing
a hole screen with SwiftUI and there is scrolling, if this is set to false,
when you navigating away from the screen and back, the scroll state will be
lose and the component will be recreated, by setting to true, the generator
will wrap your View inside a ViewModel that will survive the composition
and when going back, when reuse the same ViewController storage in the ViewModel. Notice: This should be
avoid for small components that can easily be recreated without cost, because
the ViewModel will survive even if you remove the Component from the Composition
in the same screen, in this case, having a untended memory leak until the Screen
that have started the Native view be disposed/removed from the stack.
Note: This uses Androidx ViewModel KMP under the hood, check with your Navigation library if does support it 
on iOS target.

### How the code generator works.

By annotating a Expect Composable functions the generator looks for all the functions annotated with `@ExpectSwiftView`
and their configurations. After the listing of all is where start the generation. This is the KSP part.

1. It will group all Expect Composable in a group by `Factory Name` and Generates:
   1. The `NativeViewFactory`, that is a Kotlin interface with factory functions for each Expect Composable
      receives each initial parameter from the it and returns a Pair<UIViewController, {ComposableName}Delegate>
      that will be used by the generated Actual Composable.
   2. The `Local Composition` for the `NativeViewFactory` that later the user of the tool need to provide explicit.
2. For each Expect Composable at will generate:
   1. A `{ComposableName}Delegate` that is a interface that contains functions for each parameter of the Composable for
      when it state changes. The generated ObservableObject uses this to keep the state at SwiftUI update, the user can optin
      implement the Delegate by it self, for example, integrating with UIKit.
   2. If is configured to use SwiftUI, it will generate a ObservableObject called `{ComposableName}Observable` that will
      contain Published states for each parameter of the Expect Composable by implementing the `{ComposableName}Delegate` interface.
   3. The most import part is generating the actual function for the Expect Function you have annotated.
      This is done by generating the actual function at iOS Targets and the internals containing the code to render UIViewController from the 
      the `NativeViewFactory` fetched from from the `Local Composition` and also keeps listen to states changes from the function parameter
      in order to call `{ComposableName}Delegate` update functions. The generated code also handles if you configure with `keepStateCrossNavigation`,
      if so, it will store the UIViewController and the Delegate in a ViewModel (The reason for use `keepStateCrossNavigation` was explained in the topic before).